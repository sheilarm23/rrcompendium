---
title: "rawPaper"
author: Sheila RM
date: today
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{bash, eval = FALSE}
---

# this is the preamble
```

## Abstract

Keywords: 


## Introduction


## Materials and Methods
1- text here

Tetis (19–28 mm standard length) were collected 400 m from the river mouth of Río Yumurí (Figure 1), eastern Cuba, in December, 2018. Samples were collected using hand nets (1 mm mesh size) 2 m from the riverbank. Specimens were anesthetized using MS 222 (Tricaine Methanesulphonate) and immediately preserved in 80% ethanol. Voucher specimens were deposited in the collection of the Acuario Nacional de Cuba (catalog number: ). 

2- map 

```{r, echo=FALSE}
#chunk for generating the MAP.

install.packages("maps")
install.packages("mapdata")

library(maps)
library(mapdata)
map("worldHires","Cuba", xlim=c(-88,-73), ylim=c(19,24), col="gray95", fill=TRUE)


```

3- text for dna extraction

Total DNA was extracted from caudal peduncle muscle tissues using the DNAeasy tissue kit (QIAGEN). Partial sequences of the mitochondrial gene cytochrome oxidase I (COI) were amplified through the polymerase chain reaction in 20 μL of reaction volume (one unit of GoTaq DNA polymerase-Promega, 0.2 nM of each primer, 0.2 μM dNTPs, and 1.5 mM MgCl2) following Lara et al. (2010). We used the primers COIf (5´-AAYCAYAAAGAYGGYACCCT-3´) and COIr (3´-CCTCNGGRTGNCCRAAGAAYCA-5´) (Palumbi et al., 1991).  

PCR products were purified using ExoSAP-IT™ PCR Product Cleanup Reagent (Affymetrix Inc./ USB, Cleveland, OH, USA), and then sequenced on an ABI 3100 automated sequencer (Applied Biosystems). Raw sequence files were edited and aligned with the software Geneious v.9.1 (Kearse et al., 2012), and submitted to GenBank database (accession numbers #####). We used all Sicydium sequences available in GenBank as reference for recovering the taxonomic identity of the tetis. Sequences with missing data and/or carrying the same haplotype were excluded. Sequences of Awaous banana and A. ocellaris were used as outgroup. See Appendix 1 for a detailed list of species and GenBank accession numbers.

```{r, echo=FALSE}

                                                      # INSTALLING PACKAGES AND LIBRARIES - if needed
packages = c("rentrez", "ape", "seqinr", "BiocManager", "modelTest")
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("msa")
BiocManager::install("systemPipeR")
library(stringr)
library(systemPipeR)
                                                       # DOWNLOADING SEQS FROM GENBANK

# rentrez: this package provides an R interface NCBI API and allows to search databases like GenBank (http://www.ncbi.nih.gov/genbank/) 
library(rentrez)     # delete this line after finishing

Sicydium_COI <- "Sicydium[Organism] AND COI[Gene]"

# I set retmax=580 because after running this by default, I got a message with the number of hits (580 in this case)
Sicydium_COI_search <- entrez_search(db = "nuccore", term = Sicydium_COI, retmax = 580)

# given that the search is too big for the system, it needs be split in two smaller one
Sicydium_COI_seqs1 <- entrez_fetch(db = "nuccore", id = Sicydium_COI_search$ids[0:295], rettype = "fasta")
Sicydium_COI_seqs2 <- entrez_fetch(db = "nuccore", id = Sicydium_COI_search$ids[296:580], rettype = "fasta")

# GETTING OUTGROUP SEQUENCES OF AWAOUS BANANA (2) AND A. OCELLARIS (2)

Awaous_bananaCOI <- "Awaous_banana[Organism] AND COI[Gene]"
Awaous_bananaCOI_search <- entrez_search(db = "nuccore", term = Awaous_bananaCOI, retmax = 2)
Awaous_bananaCOI_seqs <- entrez_fetch(db = "nuccore", id = Awaous_bananaCOI_search$ids, rettype = "fasta")

Awaous_ocellarisCOI <- "Awaous_ocellaris[Organism] AND COI[Gene]"
Awaous_ocellarisCOI_search <- entrez_search(db = "nuccore", term = Awaous_ocellarisCOI, retmax = 4)
Awaous_ocellarisCOI_seqs <- entrez_fetch(db = "nuccore", id = Awaous_ocellarisCOI_search$ids, rettype = "fasta")

# storing ALL sequences in a single fasta file
write(Sicydium_COI_seqs1, file="../data/raw_data/Sicydium_COI_seqs.fasta", sep = "\n")
write(Sicydium_COI_seqs2, file="../data/raw_data/Sicydium_COI_seqs.fasta", sep = "\n", append = TRUE)   # 'append = TRUE', I can keep adding seqs
write(Awaous_bananaCOI_seqs, file="../data/raw_data/Sicydium_COI_seqs.fasta", sep = "\n", append = TRUE)
write(Awaous_ocellarisCOI_seqs, file="../data/raw_data/Sicydium_COI_seqs.fasta", sep = "\n", append = TRUE)


                                                   # RENAMING SEQS AND SAVING THEM IN A NEW FASTA FILE

# seqinr: package for sequence manipulation 

library(seqinr)     # delete this line after finishing

# reading the file and renaming the sequences
Sicydium_COI_seqinrFormat <- read.fasta(file ="../data/raw_data/Sicydium_COI_seqs.fasta", seqtype = "DNA", as.string = TRUE, forceDNAtolower = FALSE)

Sicydium_COI_names <- attr(Sicydium_COI_seqinrFormat, "name")      # editing species name
Sicydium_COI_names <- gsub("\\..*", "", Sicydium_COI_names)        # eliminating characters after "." using gsub
Sicydium_COI_names <- gsub("^.*\\|", "", Sicydium_COI_names)       # eliminating characters before "|" using gsub

# using library "ape"
library(ape)   # delete this line after finishing

Sicydium_COI_apeFormat <- read.GenBank(Sicydium_COI_names)         # this line takes a few minutes to run

#attr(Sicydium_COI_apeFormat, "species")
#names(Sicydium_COI_apeFormat)

# creating a vector (to be added as name of the seqs) with the species, GenBank accession number, and type of gene
Sicydium_COI_GenBank_Ids <- paste(attr(Sicydium_COI_apeFormat, "species"), names(Sicydium_COI_apeFormat), sep = "_COI_")

# writing a new fasta file (2nd) using the vector above 
write.fasta(sequences = Sicydium_COI_seqinrFormat, names = Sicydium_COI_GenBank_Ids, nbchar = 10, file.out = "../data/raw_data/Sicydium_COI_seqinrFormat")


                                     # ALIGNIG/EDITTING SEQS AND GETTING THEM ALL READY FOR THE PHYLOGENETIC ANALYSIS

### REMOVING sequences of incomplete/unspecific NAMES; that is, those with 'sp.'
nameFasta <- read.fasta(file = "../data/raw_data/Sicydium_COI_seqinrFormat", seqtype = "DNA", as.string = TRUE, forceDNAtolower = FALSE)

fastaNames <- strsplit(names(nameFasta), '_')                  # creating a vector splitting species names
completeSeqs <- which(! grepl("sp.", fastaNames))              # selecting only those with specific name in them       # 562 seqs

# writing a new fasta (3rd) file with only those seqs with full scientific names
write.fasta(sequences = nameFasta[completeSeqs], names = names(nameFasta)[completeSeqs], file.out = "../data/raw_data/Sicydium_COI_names.fasta")

### REMOVING sequences of LENGTH shorter than 600 pb, given that the gene COI has between 627 and 658 bp.
lengthFasta <- read.fasta(file = "../data/raw_data/Sicydium_COI_names.fasta", seqtype = "DNA", as.string = TRUE, forceDNAtolower = FALSE)
fastaLength <- lengthFasta[which(getLength(lengthFasta) >= 600)]       
write.fasta(sequences = fastaLength, names = names(fastaLength), file.out = "../data/raw_data/Sicydium_COI_lengths.fasta")      # 399 seqs

### Aligning the sequences    # using libraries "msa" and "Biostrings"
library(msa)           # delete this line after finishing
library(Biostrings)    # delete this line after finishing

alignmentFasta <- readDNAStringSet("../data/raw_data/Sicydium_COI_lengths.fasta")
ClustalOAlignment <- msa(alignmentFasta, "ClustalOmega")   # algorithm Clustal Omega (Sievers et al. 2011) used for aligning
#print(ClustalOAlignment, showConsensus=FALSE, showNames=TRUE, show="complete") 

# REMOVING samples with to many GAPS at the beginning and the end of the sequences 
colmask(ClustalOAlignment) <- IRanges(start=c(1,666),end=c(13,679))                
ClustalOAlignment2 <- as(ClustalOAlignment, "DNAStringSet")
writeXStringSet(ClustalOAlignment2, file="../data/raw_data/Sicydium_COI_alignment.fasta")         # 399 seqs of 652 bp.

### Removing DUPLICATE sequences    # using "seqinr" to do it

# for not using attributes to name sequences
duplicatesFasta <- read.fasta("../data/raw_data/Sicydium_COI_alignment.fasta", set.attributes = FALSE) 
seqnames <- names(duplicatesFasta)
dups <- grep(TRUE,duplicated(duplicatesFasta))
uniqueNames <- seqnames[-dups]
uniqueSeqs <- duplicatesFasta[-dups] 
write.fasta(sequences = uniqueSeqs, names = uniqueNames, file.out = "../data/raw_data/Sicydium_COI_dupli.fasta")      # 197 seqs of 652 bp.

### Replacing gaps with Ns
library(stringr)

gapsFasta <- read.fasta(file = "../data/raw_data/Sicydium_COI_dupli.fasta", seqtype = "DNA", as.string = TRUE, forceDNAtolower = FALSE)
replacingGaps <- lapply(gapsFasta, function(x) str_replace_all(x, "-", "N"))
write.fasta(replacingGaps,names(replacingGaps),"../data/raw_data/Sicydium_COI_gaps.fasta") 

# GETTING the READING FRAME
BiocManager::install("systemPipeR")    # delete this line after finishing
library(systemPipeR)

gettingRF <- function(x){
  fasta <- readDNAStringSet("../data/raw_data/Sicydium_COI_gaps.fasta")
  orf1 <- predORF(fasta[1:10], n=1, type="df", mode="orf", strand="sense")   # predORF() do not read seqs with gaps
  # predicts longest ORF for sense strand in each query sequence                                                                          
  longestSeq1 <- orf1$start[orf1$width == max(orf1$width)]
  codonPosition1 <- longestSeq1[1]/3
  codonConfirmation1 <- round(codonPosition1)
  if (codonPosition1==codonConfirmation1){
   file.rename("../data/raw_data/Sicydium_COI_gaps.fasta", "../data/raw_data/Sicydium_COI_newRF.fasta") 
  print("The Reading Frame of these seqs is +1, no further action is required, go to modelTesting")
    } else {
    if (codonPosition1!=codonConfirmation1){
      tempLength <- length(fasta[[1]])
      #remove first nucleotide position
      newRF2 <- subseq(fasta, start = 2, end = tempLength)      # 651 bp
      # getting new RF from the new alignment with -1 bp.
      orf2 <- predORF(newRF2[1:10], n=1, type="df", mode="orf", strand="sense") 
      # checking size gain
      longestSeq2 <- orf2$start[orf2$width == max(orf2$width)]
      codonPosition2 <- (longestSeq2[1]+2)/3
      codonConfirmation2 <- round(codonPosition2)
      if (codonPosition2==codonConfirmation2){
        writeXStringSet(newRF2, file="../data/raw_data/Sicydium_COI_newRF.fasta")
      print("The Reading Frame of these seqs was +2, new fasta file created, go to modelTesting")
      } else {
      if (codonPosition2!=codonConfirmation2){
        #remove first nucleotide position
        tempLength <- length(fasta[[1]])
        newRF3 <- subseq(fasta, start = 3, end = tempLength)
        writeXStringSet(newRF3, file="../data/raw_data/Sicydium_COI_newRF.fasta")
      print("The Reading Frame of these seqs was +3, new fasta file created, go to modelTesting")
     }
   }  
  }
 }
}

gettingRF(x)



```

9- text for phylogenetic analyses

The partition scheme and nucleotide substitution model that best fitted the data was estimated using PartitionFinder 2 (Lanfear et al., 2016). The phylogenetic tree was reconstructed using the Bayesian approach using MrBayes 3.2.7a (Ronquist et al., 2012) as implemented in CIPRES (Miller et al., 2010). The Bayesian inference was based on two independent runs using four Monte Carlo Markov chains for 20 x 106 generations, with sampling every 10,000 generations. The first 25% of the sampled trees were discarded as burn-in. 



```{r, echo=FALSE}

                                          # FINDING THE BEST NUCLEOTIDE SUSBSTITUTION MODEL
BiocManager::install("modelTest")
install.packages("ape")

install.packages("phangorn")
library(phangorn)

#gettingBestModel <- function(x){
  modelFasta <- read.dna(file="../data/raw_data/Sicydium_COI_newRF.fasta", format = "fasta")
  formatPhyDat <- as.phyDat(modelFasta)                #getting the class used by modelTest: phyDat or pml
  modelChoice <- modelTest(formatPhyDat, tree = NULL, model = c("JC", "K80", "HKY", "TrN", "SYM", "GTR"), multicore = TRUE, mc.cores = 4)
  modelChoice[order(modelChoice$AICc),]   # getting the AICc for each competing model
  bestmodel <- modelChoice$Model[which.min(modelChoice$AICc)]
  #return(bestmodel)
#}

# visually inspecting the AICc is better than just getting the best model automatically, because it allows to compares models with similar AICc and it is my personal opinion to choose the one with the least parameters.  

# the alternative is to get automatically the first model from the data.frame modelTest gives and storing it as a variable...
#gettingBestModel(x)        # HKY+G+I



```



10- Results






```{r, echo=FALSE}

                                        # FINDING THE BEST NUCLEOTIDE SUSBSTITUTION MODEL
# getting the tree

library(phangorn)
env = attr(modelChoice, "env")
fitStart = eval(get(bestmodel, env), env)    # initial fit for the model chosen

fit = optim.pml(fitStart, rearrangement = "stochastic", optGamma=TRUE, optInv=TRUE, model="HKY")     # seeking a maximum likelihood solution
bs = bootstrap.pml(fit, bs=100, optNni=TRUE, multicore=TRUE)

# verifying that the optimized tree is indeed better than the original one using standard likelihood ratio tests and AIC
compareTrees <- anova(fitStart, fit)          # AICc(fitStart)       # AICc(fit)   
# Both the ANOVA test (highly significant) and the AIC (lower=better) indicate that the new tree is a better model of the data than the initial one.

# saving the tree in folder analysis/figures/
bsTree <- plotBS(midpoint(fit$tree), bs, p = 75, type="p", bs.col = "blue")     # fit$tree is where the optimal tree is stored
plotBS(bsTree, type = "p", cex = 0.2, font = 1)
write.tree(bsTree, file="../figures/Sicydium_ML_tree.tre")                      # export tree with bootstrap values as node labels

# add.scale.bar(cex = 0.7, font = 2, col = "red")

#plot(bsTree, type = "phylogram", use.edge.length = FALSE, show.node.label = TRUE, label.offset = 10,  node.depth = 1)

BiocManager::install("ggtree")
library(ggtree)

tree <- read.tree(file="../figures/Sicydium_ML_tree.tre")

# getting the node number for each main clade
nodeNumber <- NA

ggtree(tree) + geom_text(aes(label=node), hjust=-.5, col = "blue") # looks horrible but gives me the clade number

# editing/visualizing the tree
tree2 <-ggtree(tree, size = .4) + geom_treescale(x=0, y=-1.5, offset = -4) + geom_text2(aes(label=label, subset = !is.na(as.numeric(label)) & as.numeric(label) > 70), size = 3, col= "black", vjust = -0.3, hjust=1.9, na.rm = FALSE) + geom_cladelabel(node=206, label="Sicydium plumieri", color="red") + geom_cladelabel(node=113, label="Sicydium brevifile", color="blue") + geom_cladelabel(node=307, label="Sicydium salvini", color="purple") + geom_cladelabel(node=314, label="Sicydium punctatum", color="brown") + geom_cladelabel(node=363, label="Sicydium buscki", color="black") + geom_cladelabel(node=312, label="Sicydium crenilabrum", color="pink") + geom_hilight(node=369, fill="green") + theme(plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"))


tree2
+ ggplot2::xlim(0, 0.06) + xlim(0, 1) 
geom_nodelab(size = 7, col= "red") + theme_tree2() + ylim(0,15)

ggtree(tree) + geom_text2(aes(subset = !isTip, label=label))
# ggtree(tree) + geom_text2(aes(label=label, subset = !is.na(as.numeric(label)) & as.numeric(label) > 80))
plot(bsTree, no.margin = TRUE, cex = 0.5)
add.scale.bar(bsTree, lwd = 1, cex = 0.7, font = 2, col = "red")


# saving the tree as a png figure
ggsave(tree2, width = 15, height = 23, units = "cm", limitsize = FALSE, file = "../figures/Sicydium_ML_tree1.png")


```


11- Discussion





12- Acknowledgments 

Habitat 

stri 

13- References 












